10. 배열
배열의 선언 : 주로 기호상수를 사용, 배열 이름은 배열의 주소를 가리킴
array_type array_name[count];

인덱싱
0부터 시작. 배열크기를 초과하는 범위도 인덱싱은 가능하지만 쓰레기값 반환.

배열의 초기화
int arr[3];  // {cc, cc, cc} 쓰레기값
int arr[3] = {1, 2, 3};  // {1, 2, 3} 적은대로
int arr[3] = {1};  // {1, 0, 0} 나머지는 0
int arr[3] = {0};  // {0, 0, 0} 위와 동일 나머지는 0

배열 요소 개수 계산
int size = sizeof(arr) / sizeof(arr[0]);  // 배열총크기 / 배열원소1개크기

배열 복사, 비교 : 깊은복사를 사용

배열과 함수 : 배열의 원형 전달
int func(int arr[], int size);

배열 변형 금지 : const로 전달

2차원 배열 선언
int arr[row][col];

2차원 배열 초기화  // 1차원배열과 같이 주어진 개수가 적으면 나머지는 0으로 초기화.
    메모리상에는 1차원배열로 배치되기 때문에 1차원 배열로 계산해도 오류는 안남.
int arr[2][3] = {  // 모두 명시
    {1, 2, 3},
    {4, 5, 6}
};
int arr[][3] = {  // 열의 개수는 반드시 지정. 행은 컴파일러가 자동으로
    {1, 2, 3},
    {4, 5, 6}
};
int arr[][3] = {
    1, 2, 3, 4, 5, 6
};

2차원 배열과 함수
int func(int arr[row][col], int size);  // row는 생략가능

배열의 정렬은 자료구조에서 구현




11. 포인터
포인터 : 메모리의 주소를 가진 변수

& : 주소연산자
int i = 0; printf("%x", &i);

포인터 선언
var_type * var_name;
int* ptr = NULL;  // NULL로 초기화 하는 습관 들이기. #define NULL ((void *)0)
int* p1, * p2, * p3;  // 여러 변수 선언

포인터 초기화
int* ptr = (int*)1000;  // 절대주소값 대입
int* ptr = &i;  // 변수의 주소값 대입

* : 간접 참조 연산자. 포인터 변수가 가리키는 곳의 값.

v = *p++ : p가 가리키는 값을 v에 대입한 후에 p를 증가
v = (*p)++ : p가 가리키는 값을 v에 대입한 후에 p가 가리키는 값을 증가
v = *++p : p를 증가시킨 후에 p가 가리키는 값을 v에 대입
v = ++*p : p가 가리키는 값을 증가하여 v에 대입

포인터의 형변환
pi = (int*)pd;

호출
void swap(int x, int y);  // call by value
void swap(int *px, int *py);  // call by address

함수에서 포인터를 반환할 때 스코프에 의하여 없어지는 값의 포인터를
반환하는 것은 아닌지 주의

포인터와 배열
int arr[3];  // 이 있을 떄
arr + 1
*(arr + 1)  // 이 둘은 동일함

함수와 배열과 포인터
void print_arr(int* ptr, int size);  // 배열을 배열이 아닌 포인터로 받기. 차이는 없음




12. 문자와 문자열
문자열의 초기화 : 맨 마지막에 NULL문자 '\0'가 존재해야함
char str[4] = {'a', 'b', 'c', '\0'};
char str[4] = "abc";
char str[4] = "abcdef";  // {'a', 'b', 'c', 'd'}로 NULL문자 추가 안됨. 컴파일 경고 발생
char str[6] = "abc";  // {'a', 'b', 'c', '\0', '\0', '\0'}
char str[4] = "";  // {'\0', '\0', '\0', '\0'}
char str[] = "abc";  // {'a', 'b', 'c', '\0'}로 크기 자동 부여

문자열과 포인터
char* p = "HelloWorld";  // 포인터 변수가 data segment에 저장, 문자열이 text segment에 저장.
    문자열을 변경할 순 없지만, text segment에 있는 문자열을 가리키도록 할 순 있음.
